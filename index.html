<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Telecom Data Analyzer</title>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <!-- SheetJS for Excel parsing -->
  <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
  <!-- Add Bootstrap for better styling -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <style>
      body { font-family: Arial, sans-serif; margin: 20px; }
      table { width: 100%; border-collapse: collapse; margin-top: 20px; }
      th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
      th { background-color: #f2f2f2; cursor: pointer; }
      input, select, button { margin: 5px 10px 5px 0; }
      .filter-group { margin: 10px 0; }
      .name-mapping { border: 1px solid #ddd; padding: 10px; margin-bottom: 20px; }
      .nav-tabs { margin-bottom: 20px; }
      .tab-content { padding: 20px 0; }
      .data-type-config { border: 1px solid #ddd; padding: 15px; margin-bottom: 15px; border-radius: 5px; }
      .field-mapping { margin-bottom: 10px; }
      .dropdown-menu { max-height: 300px; overflow-y: auto; }
  </style>
</head>
<body>
<div class="container-fluid">
  <!-- Main Tabs -->
  <ul class="nav nav-tabs" id="mainTabs" role="tablist">
    <li class="nav-item" role="presentation">
      <button class="nav-link active" id="viewer-tab" data-bs-toggle="tab" data-bs-target="#viewer" type="button" role="tab">Data Viewer</button>
    </li>
    <li class="nav-item" role="presentation">
      <button class="nav-link" id="config-tab" data-bs-toggle="tab" data-bs-target="#config" type="button" role="tab">Data Type Configuration</button>
    </li>
  </ul>

  <div class="tab-content" id="mainTabsContent">
    <!-- Data Viewer Tab -->
    <div class="tab-pane fade show active" id="viewer" role="tabpanel" aria-labelledby="viewer-tab">
      <!-- Name Mapping Section Moved to the Top -->
      <div class="card mb-3">
        <div class="card-header">
          <h5>Name Mapping</h5>
        </div>
        <div class="card-body">
          <div class="row mb-2">
            <div class="col-md-4">
              <input type="text" class="form-control" id="mapPhone" placeholder="Phone Number">
            </div>
            <div class="col-md-4">
              <input type="text" class="form-control" id="mapName" placeholder="Assign Name">
            </div>
            <div class="col-md-4">
              <button class="btn btn-primary" onclick="assignName()">Assign Name</button>
            </div>
          </div>
          <div class="row">
            <div class="col-md-6">
              <button class="btn btn-secondary" onclick="exportNameMapping()">Export Name Mapping CSV</button>
            </div>
            <div class="col-md-6">
              <div class="input-group">
                <input type="file" class="form-control" id="importMappingFile" accept=".csv" onchange="importNameMapping(event)">
                <label class="input-group-text" for="importMappingFile">Import Mapping</label>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="card mb-3">
        <div class="card-header">
          <h5>Upload Files</h5>
        </div>
        <div class="card-body">
          <div class="row mb-2">
            <div class="col-md-6">
              <input type="file" class="form-control" id="csvFile" multiple accept=".csv,.xlsx,.xls">
            </div>
            <div class="col-md-3">
              <button class="btn btn-primary" onclick="processFiles()">Process Files</button>
            </div>
            <div class="col-md-3">
              <select class="form-select" id="fileTypeSelector">
                <option value="auto">Auto-detect File Type</option>
                <option value="call">Call Records</option>
                <option value="text">Text/MMS Records</option>
                <option value="device">Device Info</option>
                <option value="payment">Payment Records</option>
                <option value="account">Account Info</option>
                <option value="other">Other</option>
              </select>
            </div>
          </div>
          <div id="fileTypeDetection" class="alert alert-info" style="display: none;">
            File type detected: <span id="detectedFileType"></span>
            <button class="btn btn-sm btn-outline-primary ms-3" id="createTypeBtn" style="display: none;">Create Custom Type</button>
          </div>
        </div>
      </div>

      <div class="card mb-3">
        <div class="card-header d-flex justify-content-between">
          <h5>Search & Filters</h5>
          <div>
            <button class="btn btn-sm btn-primary" type="button" data-bs-toggle="collapse" data-bs-target="#searchCollapse">
              Toggle Search Panel
            </button>
          </div>
        </div>
        <div class="collapse show" id="searchCollapse">
          <div class="card-body">
            <div class="row mb-2">
              <div class="col-md-6">
                <input type="text" class="form-control" id="searchBox" placeholder="Search by any text" oninput="searchTable()">
              </div>
              <div class="col-md-3">
                <select class="form-select" id="activeDataType">
                  <option value="all">All Data Types</option>
                  <!-- Will be populated dynamically -->
                </select>
              </div>
              <div class="col-md-3">
                <div class="btn-group" role="group">
                  <button class="btn btn-outline-primary" onclick="applyAdvancedFilters()">Apply Filters</button>
                  <button class="btn btn-outline-secondary" onclick="resetFilters()">Reset</button>
                </div>
              </div>
            </div>

            <div id="dynamicFilters">
              <!-- Dynamic filter UI will be inserted here based on file type -->
            </div>

            <div class="mt-3" id="callDataFilters">
              <h6>Call Record Filters</h6>
              <div class="row">
                <div class="col-md-3">
                  <label for="startDate">Start Date:</label>
                  <input type="datetime-local" class="form-control" id="startDate">
                </div>
                <div class="col-md-3">
                  <label for="endDate">End Date:</label>
                  <input type="datetime-local" class="form-control" id="endDate">
                </div>
                <div class="col-md-3">
                  <label for="minDuration">Min Duration (s):</label>
                  <input type="number" class="form-control" id="minDuration" placeholder="Min Duration">
                </div>
                <div class="col-md-3">
                  <label for="maxDuration">Max Duration (s):</label>
                  <input type="number" class="form-control" id="maxDuration" placeholder="Max Duration">
                </div>
              </div>
              <div class="row mt-2">
                <div class="col-md-3">
                  <label for="cellTower">Cell Tower ID:</label>
                  <input type="text" class="form-control" id="cellTower" placeholder="Enter Tower ID">
                </div>
                <div class="col-md-3">
                  <label for="callDirection">Call Direction:</label>
                  <select class="form-select" id="callDirection">
                    <option value="">Any</option>
                    <option value="incoming">Incoming</option>
                    <option value="outgoing">Outgoing</option>
                  </select>
                </div>
                <div class="col-md-3">
                  <label for="searchMsisdn">Msisdn Search:</label>
                  <input type="text" class="form-control" id="searchMsisdn" placeholder="Enter Phone Number">
                </div>
                <div class="col-md-3">
                  <label for="searchLocation">Search Location:</label>
                  <input type="text" class="form-control" id="searchLocation" placeholder="e.g., Address, Location">
                </div>
              </div>
              <div class="row mt-2">
                <div class="col-md-3">
                  <label for="minTowers">Min Towers:</label>
                  <input type="number" class="form-control" id="minTowers" placeholder="Min Towers">
                </div>
                <div class="col-md-3">
                  <label for="maxTowers">Max Towers:</label>
                  <input type="number" class="form-control" id="maxTowers" placeholder="Max Towers">
                </div>
                <div class="col-md-6 mt-4">
                  <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="groupByPhone">
                    <label class="form-check-label" for="groupByPhone">
                      Group by Phone (Aggregate Towers & Locations)
                    </label>
                  </div>
                </div>
              </div>
            </div>

            <div class="mt-3" id="messageDataFilters" style="display: none;">
              <h6>Message Record Filters</h6>
              <div class="row">
                <div class="col-md-3">
                  <label for="msgStartDate">Start Date:</label>
                  <input type="datetime-local" class="form-control" id="msgStartDate">
                </div>
                <div class="col-md-3">
                  <label for="msgEndDate">End Date:</label>
                  <input type="datetime-local" class="form-control" id="msgEndDate">
                </div>
                <div class="col-md-3">
                  <label for="msgType">Message Type:</label>
                  <select class="form-select" id="msgType">
                    <option value="">Any</option>
                    <option value="sms">SMS</option>
                    <option value="mms">MMS</option>
                  </select>
                </div>
                <div class="col-md-3">
                  <label for="msgDirection">Direction:</label>
                  <select class="form-select" id="msgDirection">
                    <option value="">Any</option>
                    <option value="MO">Outgoing (MO)</option>
                    <option value="MT">Incoming (MT)</option>
                  </select>
                </div>
              </div>
              <div class="row mt-2">
                <div class="col-md-6">
                  <label for="msgContent">Message Content:</label>
                  <input type="text" class="form-control" id="msgContent" placeholder="Search message content">
                </div>
                <div class="col-md-3">
                  <label for="msgSender">Sender:</label>
                  <input type="text" class="form-control" id="msgSender" placeholder="Sender phone/address">
                </div>
                <div class="col-md-3">
                  <label for="msgRecipient">Recipient:</label>
                  <input type="text" class="form-control" id="msgRecipient" placeholder="Recipient phone/address">
                </div>
              </div>
            </div>

            <div class="mt-3" id="deviceDataFilters" style="display: none;">
              <h6>Device Info Filters</h6>
              <div class="row">
                <div class="col-md-4">
                  <label for="deviceId">Device ID/IMEI:</label>
                  <input type="text" class="form-control" id="deviceId" placeholder="Device ID or IMEI">
                </div>
                <div class="col-md-4">
                  <label for="deviceType">Device Type:</label>
                  <input type="text" class="form-control" id="deviceType" placeholder="Device type">
                </div>
                <div class="col-md-4">
                  <label for="deviceMfg">Manufacturer:</label>
                  <input type="text" class="form-control" id="deviceMfg" placeholder="Manufacturer name">
                </div>
              </div>
            </div>

            <div class="mt-3" id="dataSessionFilters" style="display: none;">
              <h6>Data Session Filters</h6>
              <div class="row">
                <div class="col-md-3">
                  <label for="dsStartDate">Start Date:</label>
                  <input type="datetime-local" class="form-control" id="dsStartDate">
                </div>
                <div class="col-md-3">
                  <label for="dsEndDate">End Date:</label>
                  <input type="datetime-local" class="form-control" id="dsEndDate">
                </div>
                <div class="col-md-3">
                  <label for="dsTowerId">Tower ID:</label>
                  <input type="text" class="form-control" id="dsTowerId" placeholder="Enter Tower ID">
                </div>
                <div class="col-md-3">
                  <label for="dsCellId">Cell ID:</label>
                  <input type="text" class="form-control" id="dsCellId" placeholder="Enter Cell ID">
                </div>
              </div>
              <div class="row mt-2">
                <div class="col-md-3">
                  <label for="dsMinDuration">Min Duration (s):</label>
                  <input type="number" class="form-control" id="dsMinDuration" placeholder="Min Duration">
                </div>
                <div class="col-md-3">
                  <label for="dsMaxDuration">Max Duration (s):</label>
                  <input type="number" class="form-control" id="dsMaxDuration" placeholder="Max Duration">
                </div>
                <div class="col-md-3">
                  <label for="dsIpAddress">IP Address:</label>
                  <input type="text" class="form-control" id="dsIpAddress" placeholder="IP Address">
                </div>
                <div class="col-md-3">
                  <label for="dsNatIpAddress">NAT IP Address:</label>
                  <input type="text" class="form-control" id="dsNatIpAddress" placeholder="NAT IP Address">
                </div>
              </div>
              <div class="row mt-2">
                <div class="col-md-3">
                  <label for="dsTechnology">Network Technology:</label>
                  <select class="form-select" id="dsTechnology">
                    <option value="">Any</option>
                    <option value="4g">4G</option>
                    <option value="5g">5G</option>
                    <option value="lte">LTE</option>
                    <option value="nr">NR</option>
                  </select>
                </div>
                <div class="col-md-3">
                  <label for="dsLocation">Location/Address:</label>
                  <input type="text" class="form-control" id="dsLocation" placeholder="Enter location or address">
                </div>
                <div class="col-md-3">
                  <label for="dsMinDataVolume">Min Data Volume (KB):</label>
                  <input type="number" class="form-control" id="dsMinDataVolume" placeholder="Min KB">
                </div>
                <div class="col-md-3">
                  <label for="dsMaxDataVolume">Max Data Volume (KB):</label>
                  <input type="number" class="form-control" id="dsMaxDataVolume" placeholder="Max KB">
                </div>
              </div>
              <div class="row mt-2">
                <div class="col-md-3">
                  <label for="dsPortAllocTime">Port Alloc Date/Time:</label>
                  <input type="text" class="form-control" id="dsPortAllocTime" placeholder="Enter port alloc time">
                </div>
                <div class="col-md-9">
                  <!-- Placeholder for future filters -->
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-header d-flex justify-content-between">
          <h5 id="tableTitle">Data Analysis</h5>
          <div>
            <button class="btn btn-sm btn-success" onclick="exportCSV()">Export Filtered CSV</button>
          </div>
        </div>
        <div class="card-body table-responsive">
          <table id="resultTable" class="table table-striped table-hover">
            <thead>
              <tr id="tableHeader">
                <!-- Header content will be set dynamically -->
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- Data Type Configuration Tab -->
    <div class="tab-pane fade" id="config" role="tabpanel" aria-labelledby="config-tab">
      <div class="card">
        <div class="card-header">
          <h5>Data Type Definitions</h5>
        </div>
        <div class="card-body">
          <div class="row mb-3">
            <div class="col-md-4">
              <select class="form-select" id="dataTypeSelector">
                <option value="">-- Select Data Type --</option>
                <option value="new">Create New Data Type</option>
                <!-- Will be populated dynamically -->
              </select>
            </div>
            <div class="col-md-8">
              <div class="btn-group" role="group">
                <button class="btn btn-primary" id="editDataTypeBtn" disabled>Edit</button>
                <button class="btn btn-success" id="saveDataTypeBtn">Save</button>
                <button class="btn btn-danger" id="deleteDataTypeBtn" disabled>Delete</button>
                <button class="btn btn-secondary" id="exportDataTypesBtn">Export Definitions</button>
                <input type="file" id="importDataTypesFile" accept=".json" style="display: none;" onchange="importDataTypeDefinitions(event)">
                <button class="btn btn-info" onclick="document.getElementById('importDataTypesFile').click()">Import Definitions</button>
              </div>
            </div>
          </div>

          <div id="dataTypeConfig" class="data-type-config">
            <div class="row mb-3">
              <div class="col-md-6">
                <label for="dtName">Data Type Name:</label>
                <input type="text" class="form-control" id="dtName" placeholder="e.g., Call Records, Text Messages">
              </div>
              <div class="col-md-6">
                <label for="dtIdentifier">File Identifier Pattern:</label>
                <input type="text" class="form-control" id="dtIdentifier" placeholder="e.g., VOLTE, TextDetail, Payment">
              </div>
            </div>

            <h6>Field Definitions</h6>
            <div id="fieldDefinitions">
              <!-- Field definition template -->
              <div class="field-mapping template" style="display: none;">
                <div class="row">
                  <div class="col-md-3">
                    <input type="text" class="form-control field-name" placeholder="Display Name">
                  </div>
                  <div class="col-md-5">
                    <input type="text" class="form-control field-keys" placeholder="Possible column names (comma separated)">
                  </div>
                  <div class="col-md-2">
                    <select class="form-control field-type">
                      <option value="text">Text</option>
                      <option value="number">Number</option>
                      <option value="date">Date</option>
                      <option value="boolean">Boolean</option>
                    </select>
                  </div>
                  <div class="col-md-2">
                    <div class="btn-group btn-group-sm" role="group">
                      <button class="btn btn-sm btn-danger remove-field">Remove</button>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <button class="btn btn-outline-primary mt-3" id="addFieldBtn">Add Field</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  // Global variables
  let currentDataset = [];
  let currentFilteredDataset = []; // To store the filtered dataset
  let nameMapping = {}; // Global mapping for phone numbers to names
  let dataTypeDefinitions = {}; // To store data type definitions
  let detectedDataTypes = new Set(); // Currently detected data types
  let currentFields; // To store current fields for dynamic filtering

  // Initialize with built-in data types
  function initializeDataTypes() {
    // Call Records data type
    dataTypeDefinitions.call = {
      name: "Call Records",
      identifier: "volte|voci|call|cdr",
      fields: [
        { name: "Msisdn", keys: ["msisdn", "volte msisdn"], type: "text" },
        { name: "Search Value", keys: ["search value", "volte search value"], type: "text" },
        { name: "Search Start", keys: ["search start (gmt)", "volte search start (gmt)"], type: "date" },
        { name: "Search End", keys: ["search end (gmt)", "volte search end (gmt)"], type: "date" },
        { name: "Record Open Time", keys: ["rcd open dt/tm (gmt)", "record open dt/tm(gmt)", "record open date/time", "volte rcd open dt/tm(gmt)", "volte record open date/time"], type: "date" },
        { name: "Duration", keys: ["timeusage", "sou"], type: "number" },
        { name: "Call Direction", keys: ["calldirection", "dir", "volte dir"], type: "text" },
        { name: "Calling Party", keys: ["calling party no", "cpn", "volte cpn", "volte calling party no"], type: "text" },
        { name: "Called Party", keys: ["called prty addr", "called #", "volte called #", "volte called prty addr"], type: "text" },
        { name: "Primary Tower", keys: ["mkt enodeb id", "enb id", "market id", "volte enb id", "volte market id", "volte mkt enodeb id"], type: "text" },
        { name: "Cell ID", keys: ["ani cell id", "cell id", "volte cell id", "volte ani cell id"], type: "text" }
      ]
    };

    // Text Messages data type
    dataTypeDefinitions.text = {
      name: "Text Messages",
      identifier: "sms|text|mms|message|textdetail",
      fields: [
        { name: "Message Time", keys: ["messagearrival", "record date/time", "submission date/time"], type: "date" },
        { name: "Message Type", keys: ["network element name"], type: "text" },
        { name: "Direction", keys: ["charge information"], type: "text" },
        { name: "Sender", keys: ["originator address", "originatingmdn"], type: "text" },
        { name: "Recipient", keys: ["recipient address", "recipient addresses", "terminatingmdn"], type: "text" },
        { name: "Content", keys: ["messagecontent"], type: "text" },
        { name: "Status", keys: ["messagefinalstatus", "finaldisposition"], type: "text" },
        { name: "Size", keys: ["message size"], type: "number" },
        { name: "Msisdn", keys: ["searchmtn", "mdn"], type: "text" }
      ]
    };

    // Device Info data type
    dataTypeDefinitions.device = {
      name: "Device Information",
      identifier: "device|imei|deviceid",
      fields: [
        { name: "Msisdn", keys: ["mtn"], type: "text" },
        { name: "MIN", keys: ["min"], type: "text" },
        { name: "Device ID", keys: ["device_id"], type: "text" },
        { name: "IMEI", keys: ["imei"], type: "text" },
        { name: "IMSI", keys: ["imsi"], type: "text" },
        { name: "Manufacturer", keys: ["mfg_name"], type: "text" },
        { name: "Device Name", keys: ["eqp_name"], type: "text" },
        { name: "Device Type", keys: ["device_type"], type: "text" },
        { name: "Status", keys: ["mtn_status"], type: "text" },
        { name: "Effective Date", keys: ["mtn_effective_date"], type: "date" }
      ]
    };

    // Account Info data type
    dataTypeDefinitions.account = {
      name: "Account Information",
      identifier: "account|actdeact|subscriber|ssn",
      fields: [
        { name: "Msisdn", keys: ["search value", "mtn"], type: "text" },
        { name: "Account Number", keys: ["account number"], type: "text" },
        { name: "Name", keys: ["last name", "first name", "business name"], type: "text" },
        { name: "Status", keys: ["mtn status code"], type: "text" },
        { name: "Effective Date", keys: ["mtn effective date"], type: "date" },
        { name: "Disconnect Date", keys: ["disconnect date"], type: "date" }
      ]
    };

    // Payment data type
    dataTypeDefinitions.payment = {
      name: "Payment Records",
      identifier: "payment|invoice|bill",
      fields: [
        { name: "Msisdn", keys: ["search mtn"], type: "text" },
        { name: "Account Number", keys: ["account number"], type: "text" },
        { name: "Date", keys: ["date", "invoice date"], type: "date" },
        { name: "Amount", keys: ["payment amount"], type: "number" },
        { name: "Payment Method", keys: ["payment method"], type: "text" },
        { name: "Payment Source", keys: ["payment source"], type: "text" },
        { name: "Payment Status", keys: ["payment status"], type: "text" }
      ]
    };

    // Data Session/Cell Site data type
    dataTypeDefinitions.datasession = {
      name: "Data Session Records",
      identifier: "cellsites|cell-sites|data_sessions|data sessions|4g|5g|tdr|ip|p-bdr",
      fields: [
        { name: "MSISDN", keys: ["msisdn", "phone", "phonenumber", "number", "device_number", "calling_number"], type: "text" },
        { name: "Session Start", keys: ["session_start", "start_time", "starttime", "session_date", "date", "start_date"], type: "date" },
        { name: "Session End", keys: ["session_end", "end_time", "endtime", "end_date"], type: "date" },
        { name: "Duration", keys: ["duration", "session_duration", "time", "seconds"], type: "number" },
        { name: "Cell ID", keys: ["cell_id", "cellid", "cell", "sector", "sector_id", "sectorid"], type: "text" },
        { name: "Tower ID", keys: ["tower_id", "towerid", "tower", "site_id", "siteid"], type: "text" },
        { name: "Sector", keys: ["sector", "cell_sector", "sectorid", "sector_id"], type: "text" },
        { name: "Data Volume", keys: ["data_volume", "volume", "data_usage", "usage", "bytes", "kb", "mb", "data"], type: "number" },
        { name: "IP Address", keys: ["ip", "ip_address", "ipaddress", "mbl_ip", "mbl_ip_addr", "mbl ip addr"], type: "text" },
        { name: "NAT IP Address", keys: ["nat_ip", "nat_ip_address", "nat ipaddress", "nat ip addr", "ext_ip"], type: "text" },
        { name: "IMEI", keys: ["imei", "device_id", "deviceid", "equipment_id"], type: "text" },
        { name: "Location", keys: ["location", "cell_location", "tower_location", "site_location"], type: "text" },
        { name: "Technology", keys: ["technology", "tech", "network_type", "networktype", "service_type"], type: "text" },
        { name: "Port Alloc Date/Time", keys: ["port_alloc_date_time", "port_alloc_date", "port allocation date/time", "port_allocation_date", "port alloc"], type: "date" }
      ]
    };

    // Update data type selectors
    updateDataTypeSelectors();
  }

  // Update data type selectors in the UI
  function updateDataTypeSelectors() {
    const dataTypeSelector = document.getElementById('dataTypeSelector');
    const activeDataType = document.getElementById('activeDataType');
    
    // Clear existing options except default ones
    while (dataTypeSelector.options.length > 2) {
      dataTypeSelector.remove(2);
    }
    
    while (activeDataType.options.length > 1) {
      activeDataType.remove(1);
    }
    
    // Add options for each data type
    for (const [key, dataType] of Object.entries(dataTypeDefinitions)) {
      const option1 = document.createElement('option');
      option1.value = key;
      option1.textContent = dataType.name;
      dataTypeSelector.appendChild(option1);
      
      const option2 = document.createElement('option');
      option2.value = key;
      option2.textContent = dataType.name;
      activeDataType.appendChild(option2);
    }
    
    // Add detected data types to active data type selector
    detectedDataTypes.forEach(type => {
      if (dataTypeDefinitions[type]) {
        const option = document.createElement('option');
        option.value = type;
        option.textContent = dataTypeDefinitions[type].name;
        if (!Array.from(activeDataType.options).some(opt => opt.value === type)) {
          activeDataType.appendChild(option);
        }
      }
    });
  }

  // Create field definition UI
  function createFieldDefinitionUI(field = null) {
    const template = document.querySelector('.field-mapping.template');
    const newField = template.cloneNode(true);
    newField.classList.remove('template');
    newField.style.display = '';
    
    if (field) {
      newField.querySelector('.field-name').value = field.name;
      newField.querySelector('.field-keys').value = field.keys.join(', ');
      newField.querySelector('.field-type').value = field.type;
    }
    
    newField.querySelector('.remove-field').addEventListener('click', function() {
      newField.remove();
    });
    
    document.getElementById('fieldDefinitions').appendChild(newField);
    return newField;
  }

  // Helper function to get field value from a record using multiple possible keys
  function getField(record, possibleKeys) {
    // Check for exact key matches first
    for (const key of possibleKeys) {
      if (record[key] !== undefined && record[key] !== null && record[key] !== "") {
        return record[key];
      }
    }
    
    // If no exact match, try case-insensitive matching with special handling for NAT vs non-NAT fields
    const recordKeys = Object.keys(record);
    
    for (const key of possibleKeys) {
      const keyLower = key.toLowerCase();
      
      // Special handling for IP address fields to prevent overlap
      if (keyLower === "mbl ip addr" || keyLower === "ip address" || keyLower === "ip addr") {
        // When looking for regular IP address, exclude NAT fields
        for (const recordKey of recordKeys) {
          const recordKeyLower = recordKey.toLowerCase();
          if ((recordKeyLower.includes(keyLower) || keyLower.includes(recordKeyLower)) && 
              !recordKeyLower.includes("nat")) {
            return record[recordKey];
          }
        }
      } 
      else if (keyLower === "mbl ip addr nat" || keyLower === "nat ip address" || keyLower.includes("nat")) {
        // When looking for NAT IP address, only include NAT fields
        for (const recordKey of recordKeys) {
          const recordKeyLower = recordKey.toLowerCase();
          if (recordKeyLower.includes("nat") && 
              (recordKeyLower.includes("ip") || recordKeyLower.includes("address"))) {
            return record[recordKey];
          }
        }
      }
      else {
        // Standard fuzzy matching for non-IP fields
        for (const recordKey of recordKeys) {
          const recordKeyLower = recordKey.toLowerCase();
          if (recordKeyLower.includes(keyLower) || keyLower.includes(recordKeyLower)) {
            return record[recordKey];
          }
        }
      }
    }
    
    // If still no match, return empty string
    return "";
  }

  // Helper for VOLTE extras
  function getVolteExtras(record) {
    let extras = [];
    const fields = [
      { label: "SID", keys: ["sid"] },
      { label: "NID", keys: ["nid"] },
      { label: "Cell Face", keys: ["cell face"] },
      { label: "RAT", keys: ["rat"] },
      { label: "ENDPOINT", keys: ["endpoint"] },
      { label: "VZWNE/V4B", keys: ["vzwne/v4b"] }
    ];
    fields.forEach(f => {
      let val = getField(record, f.keys);
      if(val) extras.push(f.label + ": " + val);
    });
    return extras.join(" | ");
  }

  // Helper for VOCE offsets
  function getVoceOffsets(record) {
    let offsets = [];
    const fields = [
      { label: "Rcd Open Ts Offset", keys: ["rcd open ts offset"] },
      { label: "RcdCloseTsOffset", keys: ["rcdclosetsoffset"] },
      { label: "GMT Offset", keys: ["gmt offset"] }
    ];
    fields.forEach(f => {
      let val = getField(record, f.keys);
      if(val) offsets.push(f.label + ": " + val);
    });
    return offsets.join(" | ");
  }

  // Detect file type based on filename and header with improved pattern matching
  function detectFileType(fileName, headers) {
    // Convert headers to lowercase for case-insensitive matching
    const lowerHeaders = headers.map(h => h.toLowerCase());
    
    console.log("Detecting file type for:", fileName);
    console.log("Available headers:", lowerHeaders);
    
    // Special case for P-BDR data session files
    if (fileName.toLowerCase().includes('p-bdr') && 
        (fileName.toLowerCase().includes('data_sessions') || 
         fileName.toLowerCase().includes('4g') || 
         fileName.toLowerCase().includes('5g'))) {
      console.log("Special case detected: P-BDR data session file");
      return 'datasession';
    }
    
    // First try to match based on file name
    for (const [key, definition] of Object.entries(dataTypeDefinitions)) {
      const regex = new RegExp(definition.identifier, 'i');
      if (regex.test(fileName)) {
        console.log(`File type matched by name pattern: ${key} (${definition.name})`);
        return key;
      }
    }
    
    // If no match by filename, try to match by headers
    const matchScores = {};
    
    for (const [key, definition] of Object.entries(dataTypeDefinitions)) {
      let matchCount = 0;
      let totalKeyCount = 0;
      
      definition.fields.forEach(field => {
        field.keys.forEach(fieldKey => {
          totalKeyCount++;
          // Try exact match first
          if (lowerHeaders.includes(fieldKey.toLowerCase())) {
            matchCount += 2; // Give higher weight to exact matches
          } else {
            // Try partial/fuzzy matching
            for (const header of lowerHeaders) {
              if (header.includes(fieldKey.toLowerCase()) || 
                  fieldKey.toLowerCase().includes(header)) {
                matchCount += 1;
                break;
              }
            }
          }
        });
      });
      
      // Calculate match score as percentage of possible matches
      const score = (matchCount / (totalKeyCount * 2)) * 100;
      matchScores[key] = score;
      console.log(`Match score for ${key}: ${score.toFixed(2)}%`);
    }
    
    // Find data type with highest match score
    let bestMatch = null;
    let bestScore = 20; // Threshold percentage - at least 20% match required
    
    for (const [key, score] of Object.entries(matchScores)) {
      if (score > bestScore) {
        bestScore = score;
        bestMatch = key;
      }
    }
    
    if (bestMatch) {
      console.log(`Best match by headers: ${bestMatch} (${dataTypeDefinitions[bestMatch].name}) with score ${bestScore.toFixed(2)}%`);
      return bestMatch;
    }
    
    // Special case for cell site/data session files
    if (fileName.toLowerCase().includes('cellsites') || 
        fileName.toLowerCase().includes('data_sessions') ||
        (fileName.toLowerCase().includes('4g') && fileName.toLowerCase().includes('session')) ||
        (fileName.toLowerCase().includes('5g') && fileName.toLowerCase().includes('session')) ||
        fileName.toLowerCase().includes('tdr')) {
      return 'datasession';
    }
    
    console.log("No match found, returning unknown");
    return 'unknown';
  }

  // Compute a score based on total duration and unique towers.
  // (For example, score = (duration in minutes) + (unique towers * 10))
  function computeScore(record) {
    let durationMinutes = record["Total Duration"] / 60;
    let towersScore = record["Unique Towers"] * 10;
    return Math.round(durationMinutes + towersScore);
  }

  // Process selected files (CSV and Excel)
  async function processFiles() {
    const files = document.getElementById('csvFile').files;
    if (files.length === 0) {
      alert("Please select files to process.");
      return;
    }
    
    currentDataset = [];
    detectedDataTypes.clear();
    
    // Check if user selected a specific file type
    const manualFileType = document.getElementById('fileTypeSelector').value;
    
    for (const file of Array.from(files)) {
      try {
        let fileData;
        let headers = [];
        
        if (file.name.toLowerCase().endsWith('.csv')) {
          // Process CSV file
          fileData = await new Promise((resolve, reject) => {
            Papa.parse(file, {
              header: true,
              skipEmptyLines: true,
              transformHeader: header => header.trim().toLowerCase(),
              complete: function(results) {
                headers = results.meta.fields;
                resolve(results.data);
              },
              error: function(error) {
                reject(error);
              }
            });
          });
        } else if (file.name.toLowerCase().endsWith('.xlsx') || file.name.toLowerCase().endsWith('.xls')) {
          // Process Excel file
          const excelData = await processExcelFile(file);
          headers = excelData.headers;
          fileData = excelData.rows;
        } else {
          console.warn(`Unsupported file type: ${file.name}`);
          continue;
        }

        // Detect or use manual file type
        let fileType = manualFileType !== 'auto' ? manualFileType : detectFileType(file.name, headers);
        
        if (fileType === 'unknown') {
          alert(`Could not automatically determine the type of file: ${file.name}. Using default processing.`);
          // Show create type button for unknown files
          document.getElementById('fileTypeDetection').style.display = 'block';
          document.getElementById('detectedFileType').textContent = 'Unknown';
          document.getElementById('createTypeBtn').style.display = 'inline-block';
          document.getElementById('createTypeBtn').onclick = function() {
            // Switch to config tab with headers pre-filled
            document.getElementById('config-tab').click();
            document.getElementById('dataTypeSelector').value = 'new';
            // Pre-fill with detected headers
            updateDataTypeConfig();
            // Auto-generate field definitions from headers
            headers.forEach(header => {
              const field = {
                name: header.charAt(0).toUpperCase() + header.slice(1),
                keys: [header],
                type: 'text'
              };
              createFieldDefinitionUI(field);
            });
          };
        } else {
          // Show detected file type
          document.getElementById('fileTypeDetection').style.display = 'block';
          document.getElementById('detectedFileType').textContent = dataTypeDefinitions[fileType] ? 
            dataTypeDefinitions[fileType].name : fileType;
          document.getElementById('createTypeBtn').style.display = 'none';
          
          // Add to detected data types
          detectedDataTypes.add(fileType);
        }

        // Add the file type to each record
        fileData.forEach(row => {
          row.fileType = fileType;
          
          // For call records, ensure duration field is properly processed
          if (fileType === 'call') {
            row.timeusage = parseInt(row["timeusage"] || row["sou"], 10) || 0;
          }
          
          currentDataset.push(row);
        });
        
      } catch (error) {
        console.error(`Error processing file ${file.name}:`, error);
        alert(`Error processing file ${file.name}. Please check the file format and try again.`);
      }
    }

    // Update data type selector with detected types
    updateDataTypeSelectors();

    // Initially, currentFilteredDataset is the full dataset
    currentFilteredDataset = currentDataset.slice();
    
    // Show appropriate filter section based on detected data types
    updateFilterSections();
    
    // Render the data
    renderData();
  }

  // Update filter sections based on detected data types
  function updateFilterSections() {
    document.getElementById('callDataFilters').style.display = detectedDataTypes.has('call') ? 'block' : 'none';
    document.getElementById('messageDataFilters').style.display = detectedDataTypes.has('text') ? 'block' : 'none';
    document.getElementById('deviceDataFilters').style.display = detectedDataTypes.has('device') ? 'block' : 'none';
    document.getElementById('dataSessionFilters').style.display = detectedDataTypes.has('datasession') ? 'block' : 'none';
  }

  // Render data based on data types
  function renderData() {
    const activeType = document.getElementById('activeDataType').value;
    
    if (activeType === 'all') {
      // If grouped by phone is checked and we have call data
      if (document.getElementById('groupByPhone').checked && detectedDataTypes.has('call')) {
        renderAggregatedLevel(buildAggregatedDataset());
      } else {
        // Use the first detected data type for display
        const firstType = detectedDataTypes.size > 0 ? 
          Array.from(detectedDataTypes)[0] : 'call';
        renderDataByType(currentFilteredDataset, firstType);
      }
    } else {
      // Render specific data type
      const filtered = currentFilteredDataset.filter(record => record.fileType === activeType);
      renderDataByType(filtered, activeType);
    }
  }

  // Helper function to format a value based on its data type
  function formatValue(value, type) {
    if (!value) return '';
    
    switch(type) {
      case 'date':
        // Try to parse and format the date
        try {
          const date = new Date(value);
          if (!isNaN(date.getTime())) {
            return date.toLocaleString();
          }
        } catch (e) {}
        return value;
        
      case 'number':
        // Try to format as a number
        const num = parseFloat(value);
        if (!isNaN(num)) {
          return num.toLocaleString();
        }
        return value;
        
      default:
        return value;
    }
  }

  // Render data based on data type
  function renderDataByType(dataset, dataType) {
    console.log(`Rendering data for type: ${dataType}`);
    console.log(`Sample record:`, dataset.length > 0 ? dataset[0] : 'No records');
    
    if (!dataTypeDefinitions[dataType]) {
      console.error(`Data type definition not found for: ${dataType}`);
      return renderGenericTable(dataset);
    }
    
    const definition = dataTypeDefinitions[dataType];
    document.getElementById("tableTitle").innerText = `${definition.name} (${dataset.length} records)`;
    
    // Collect all fields present in the dataset that aren't in the definition
    let additionalFields = new Set();
    dataset.forEach(record => {
      Object.keys(record).forEach(key => {
        if (key !== 'fileType' && !definition.fields.some(field => field.keys.includes(key.toLowerCase()))) {
          // Check if this key isn't already captured by fuzzy matching
          let matched = false;
          for (const field of definition.fields) {
            if (getField(record, field.keys) === record[key]) {
              matched = true;
              break;
            }
          }
          if (!matched) {
            additionalFields.add(key);
          }
        }
      });
    });
    
    // Combine predefined fields with additional fields
    const allFields = [...definition.fields];
    additionalFields.forEach(field => {
      // Create a field definition for each additional field
      const fieldName = field.charAt(0).toUpperCase() + field.slice(1).replace(/_/g, ' ');
      allFields.push({ 
        name: fieldName, 
        keys: [field], 
        type: guessFieldType(dataset, field),
        isDynamic: true // Mark as dynamically discovered
      });
    });
    
    // Create table header based on the all fields
    const headerHtml = allFields.map((field, index) => 
      `<th onclick="sortTable(${index})" ${field.isDynamic ? 'class="bg-light"' : ''}>${field.name}</th>`
    ).join('');
    
    document.getElementById("tableHeader").innerHTML = headerHtml;
    
    // Render table body
    const tbody = document.querySelector('#resultTable tbody');
    tbody.innerHTML = dataset.map(record => {
      const cells = allFields.map(field => {
        let value;
        if (field.isDynamic) {
          // For dynamic fields, directly access the record
          value = record[field.keys[0]];
        } else {
          // For predefined fields, use getField for fuzzy matching
          value = getField(record, field.keys);
        }
        return `<td>${formatValue(value, field.type)}</td>`;
      }).join('');
      
      return `<tr>${cells}</tr>`;
    }).join('');
    
    // Store the current fields for dynamic filtering
    currentFields = allFields;
    
    // Update dynamic filters
    updateDynamicFilters(dataType, allFields);
  }

  // Guess the field type based on values
  function guessFieldType(dataset, field) {
    // Sample a few records to determine type
    let dateCount = 0;
    let numberCount = 0;
    let total = 0;
    
    // Check up to 20 records
    const sampleSize = Math.min(20, dataset.length);
    for (let i = 0; i < sampleSize; i++) {
      if (dataset[i] && dataset[i][field]) {
        total++;
        const value = dataset[i][field];
        
        // Check if it looks like a date
        if (value.includes('-') && value.includes(':') || 
            /^\d{1,4}[-./]\d{1,2}[-./]\d{1,4}/.test(value) ||
            !isNaN(Date.parse(value))) {
          dateCount++;
        }
        // Check if it's a number
        else if (!isNaN(parseFloat(value)) && isFinite(value)) {
          numberCount++;
        }
      }
    }
    
    // Determine type based on majority
    if (total > 0) {
      if (dateCount / total > 0.7) return 'date';
      if (numberCount / total > 0.7) return 'number';
    }
    
    return 'text'; // Default to text
  }

  // Update dynamic filters based on current data type and fields
  function updateDynamicFilters(dataType, fields) {
    const dynamicFiltersContainer = document.getElementById('dynamicFilters');
    dynamicFiltersContainer.innerHTML = '';
    
    // Only create dynamic filters for additional fields
    const dynamicFields = fields.filter(field => field.isDynamic);
    if (dynamicFields.length === 0) return;
    
    // Create dynamic filter section
    const section = document.createElement('div');
    section.className = 'mt-3';
    section.id = 'additionalFilters';
    
    const header = document.createElement('h6');
    header.textContent = 'Additional Fields Filters';
    section.appendChild(header);
    
    // Create filters in rows of 3
    let currentRow;
    
    dynamicFields.forEach((field, index) => {
      if (index % 3 === 0) {
        currentRow = document.createElement('div');
        currentRow.className = 'row mt-2';
        section.appendChild(currentRow);
      }
      
      const col = document.createElement('div');
      col.className = 'col-md-4';
      
      const label = document.createElement('label');
      label.setAttribute('for', `dynamicFilter_${field.keys[0]}`);
      label.textContent = field.name + ':';
      
      let input;
      
      if (field.type === 'date') {
        input = document.createElement('input');
        input.type = 'text';
        input.className = 'form-control';
        input.id = `dynamicFilter_${field.keys[0]}`;
        input.placeholder = 'Enter date or part of date';
      } else if (field.type === 'number') {
        input = document.createElement('input');
        input.type = 'number';
        input.className = 'form-control';
        input.id = `dynamicFilter_${field.keys[0]}`;
        input.placeholder = 'Enter number';
      } else {
        input = document.createElement('input');
        input.type = 'text';
        input.className = 'form-control';
        input.id = `dynamicFilter_${field.keys[0]}`;
        input.placeholder = `Enter ${field.name}`;
      }
      
      col.appendChild(label);
      col.appendChild(input);
      currentRow.appendChild(col);
    });
    
    dynamicFiltersContainer.appendChild(section);
  }

  // Apply advanced filters based on input fields and data types
  function applyAdvancedFilters() {
    const activeType = document.getElementById('activeDataType').value;
    let filtered = currentDataset.slice();
    
    // Apply generic text search if present
    const searchText = document.getElementById('searchBox').value.toLowerCase();
    if (searchText) {
      filtered = filtered.filter(record => {
        return Object.values(record).some(value => 
          value && value.toString().toLowerCase().includes(searchText)
        );
      });
    }
    
    // If specific data type is selected, filter to that type
    if (activeType !== 'all') {
      filtered = filtered.filter(record => record.fileType === activeType);
    }
    
    // Apply data type specific filters
    if (activeType === 'all' || activeType === 'call') {
      filtered = applyCallFilters(filtered);
    }
    
    if (activeType === 'all' || activeType === 'text') {
      filtered = applyMessageFilters(filtered);
    }
    
    if (activeType === 'all' || activeType === 'device') {
      filtered = applyDeviceFilters(filtered);
    }
    
    if (activeType === 'all' || activeType === 'datasession') {
      filtered = applyDataSessionFilters(filtered);
    }
    
    // Apply dynamic filters for any additional fields
    filtered = applyDynamicFilters(filtered);
    
    // Update currentFilteredDataset and render
    currentFilteredDataset = filtered;
    renderData();
  }

  // Apply call record specific filters
  function applyCallFilters(records) {
    const startDate = document.getElementById('startDate').value;
    const endDate = document.getElementById('endDate').value;
    const minDuration = document.getElementById('minDuration').value;
    const maxDuration = document.getElementById('maxDuration').value;
    const cellTower = document.getElementById('cellTower').value.toLowerCase();
    const callDirection = document.getElementById('callDirection').value;
    const searchMsisdn = document.getElementById('searchMsisdn').value.toLowerCase();
    const searchLocation = document.getElementById('searchLocation').value.toLowerCase();
    const minTowers = document.getElementById('minTowers').value;
    const maxTowers = document.getElementById('maxTowers').value;
    
    return records.filter(record => {
      if (record.fileType !== 'call') return true;
      
      // Date range filter
      if (startDate && getField(record, ['calldate', 'date', 'datetime', 'call_date', 'start_date', 'start']) &&
          new Date(getField(record, ['calldate', 'date', 'datetime', 'call_date', 'start_date', 'start'])) < new Date(startDate)) {
        return false;
      }
      
      if (endDate && getField(record, ['calldate', 'date', 'datetime', 'call_date', 'start_date', 'start']) &&
          new Date(getField(record, ['calldate', 'date', 'datetime', 'call_date', 'start_date', 'start'])) > new Date(endDate)) {
        return false;
      }
      
      // Duration filters
      const duration = parseInt(getField(record, ['duration', 'timeusage', 'time', 'calltime', 'sou', 'seconds']), 10);
      if (minDuration && (!duration || duration < parseInt(minDuration, 10))) {
        return false;
      }
      
      if (maxDuration && duration > parseInt(maxDuration, 10)) {
        return false;
      }
      
      // Cell tower filter
      if (cellTower) {
        const towerValue = getField(record, ['celltower', 'tower', 'cell', 'cell_id', 'cellid', 'cgis', 'cgi']).toString().toLowerCase();
        if (!towerValue.includes(cellTower)) {
          return false;
        }
      }
      
      // Call direction filter
      if (callDirection && callDirection !== 'all') {
        const direction = getField(record, ['direction', 'call_direction', 'calldir', 'dir', 'inout', 'in_out']).toString().toLowerCase();
        if ((callDirection === 'outgoing' && !['outgoing', 'out', 'o', 'mo'].includes(direction)) ||
            (callDirection === 'incoming' && !['incoming', 'in', 'i', 'mt'].includes(direction))) {
          return false;
        }
      }
      
      // MSISDN search
      if (searchMsisdn) {
        const msisdn = getField(record, ['msisdn', 'phone', 'phonenumber', 'number', 'callingnumber', 'callednumber', 'a_party', 'b_party']).toString().toLowerCase();
        if (!msisdn.includes(searchMsisdn)) {
          return false;
        }
      }
      
      // Location search
      if (searchLocation) {
        const location = getField(record, ['location', 'celllocation', 'cell_location', 'tower_location', 'area']).toString().toLowerCase();
        if (!location.includes(searchLocation)) {
          return false;
        }
      }
      
      // Tower count filters
      const towers = getField(record, ['tower_count', 'towers', 'cells', 'cell_count']);
      if (minTowers && (!towers || parseInt(towers, 10) < parseInt(minTowers, 10))) {
        return false;
      }
      
      if (maxTowers && parseInt(towers, 10) > parseInt(maxTowers, 10)) {
        return false;
      }
      
      return true;
    });
  }

  // Apply message record specific filters
  function applyMessageFilters(records) {
    const startDate = document.getElementById('msgStartDate').value;
    const endDate = document.getElementById('msgEndDate').value;
    const msgType = document.getElementById('msgType').value;
    const msgDirection = document.getElementById('msgDirection').value;
    const msgContent = document.getElementById('msgContent').value.toLowerCase();
    const msgSender = document.getElementById('msgSender').value.toLowerCase();
    const msgRecipient = document.getElementById('msgRecipient').value.toLowerCase();
    
    return records.filter(record => {
      if (record.fileType !== 'text') return true;
      
      // Date range filter
      if (startDate && getField(record, ['date', 'msgdate', 'datetime', 'message_date', 'time', 'timestamp']) &&
          new Date(getField(record, ['date', 'msgdate', 'datetime', 'message_date', 'time', 'timestamp'])) < new Date(startDate)) {
        return false;
      }
      
      if (endDate && getField(record, ['date', 'msgdate', 'datetime', 'message_date', 'time', 'timestamp']) &&
          new Date(getField(record, ['date', 'msgdate', 'datetime', 'message_date', 'time', 'timestamp'])) > new Date(endDate)) {
        return false;
      }
      
      // Message type filter
      if (msgType && msgType !== 'all') {
        const type = getField(record, ['type', 'msgtype', 'message_type', 'msg_type']).toString().toLowerCase();
        if (type !== msgType.toLowerCase()) {
          return false;
        }
      }
      
      // Message direction filter
      if (msgDirection && msgDirection !== 'all') {
        const direction = getField(record, ['direction', 'msg_direction', 'inout', 'in_out']).toString().toLowerCase();
        if ((msgDirection === 'outgoing' && !['outgoing', 'out', 'o', 'mo'].includes(direction)) ||
            (msgDirection === 'incoming' && !['incoming', 'in', 'i', 'mt'].includes(direction))) {
          return false;
        }
      }
      
      // Message content search
      if (msgContent) {
        const content = getField(record, ['content', 'body', 'message', 'text', 'msg_body']).toString().toLowerCase();
        if (!content.includes(msgContent)) {
          return false;
        }
      }
      
      // Sender search
      if (msgSender) {
        const sender = getField(record, ['sender', 'from', 'source', 'a_party']).toString().toLowerCase();
        if (!sender.includes(msgSender)) {
          return false;
        }
      }
      
      // Recipient search
      if (msgRecipient) {
        const recipient = getField(record, ['recipient', 'to', 'destination', 'b_party']).toString().toLowerCase();
        if (!recipient.includes(msgRecipient)) {
          return false;
        }
      }
      
      return true;
    });
  }

  // Apply device record specific filters
  function applyDeviceFilters(records) {
    const deviceId = document.getElementById('deviceId').value.toLowerCase();
    const deviceType = document.getElementById('deviceType').value.toLowerCase();
    const deviceMfg = document.getElementById('deviceMfg').value.toLowerCase();
    
    return records.filter(record => {
      if (record.fileType !== 'device') return true;
      
      // Device ID filter
      if (deviceId) {
        const id = getField(record, ['id', 'deviceid', 'device_id', 'imei', 'imsi', 'serialnumber', 'serial']).toString().toLowerCase();
        if (!id.includes(deviceId)) {
          return false;
        }
      }
      
      // Device type filter
      if (deviceType) {
        const type = getField(record, ['type', 'devicetype', 'device_type', 'model']).toString().toLowerCase();
        if (!type.includes(deviceType)) {
          return false;
        }
      }
      
      // Manufacturer filter
      if (deviceMfg) {
        const manufacturer = getField(record, ['manufacturer', 'mfg', 'make', 'vendor', 'brand']).toString().toLowerCase();
        if (!manufacturer.includes(deviceMfg)) {
          return false;
        }
      }
      
      return true;
    });
  }

  // Apply data session specific filters
  function applyDataSessionFilters(records) {
    const startDate = document.getElementById('dsStartDate').value;
    const endDate = document.getElementById('dsEndDate').value;
    const towerId = document.getElementById('dsTowerId').value.toLowerCase();
    const cellId = document.getElementById('dsCellId').value.toLowerCase();
    const minDuration = document.getElementById('dsMinDuration').value;
    const maxDuration = document.getElementById('dsMaxDuration').value;
    const ipAddress = document.getElementById('dsIpAddress').value.toLowerCase();
    const natIpAddress = document.getElementById('dsNatIpAddress').value.toLowerCase();
    const technology = document.getElementById('dsTechnology').value.toLowerCase();
    const location = document.getElementById('dsLocation').value.toLowerCase();
    const minDataVolume = document.getElementById('dsMinDataVolume').value;
    const maxDataVolume = document.getElementById('dsMaxDataVolume').value;
    const portAllocTime = document.getElementById('dsPortAllocTime').value;
    
    return records.filter(record => {
      if (record.fileType !== 'datasession') return true;
      
      // Session start date filter
      if (startDate && getField(record, ['session_start', 'start_time', 'starttime', 'session_date', 'date', 'start_date']) &&
          new Date(getField(record, ['session_start', 'start_time', 'starttime', 'session_date', 'date', 'start_date'])) < new Date(startDate)) {
        return false;
      }
      
      // Session end date filter
      if (endDate && getField(record, ['session_end', 'end_time', 'endtime', 'end_date']) &&
          new Date(getField(record, ['session_end', 'end_time', 'endtime', 'end_date'])) > new Date(endDate)) {
        return false;
      }
      
      // Tower ID filter
      if (towerId) {
        const tower = getField(record, ['tower_id', 'towerid', 'tower', 'site_id', 'siteid']).toString().toLowerCase();
        if (!tower.includes(towerId)) {
          return false;
        }
      }
      
      // Cell ID filter
      if (cellId) {
        const cell = getField(record, ['cell_id', 'cellid', 'cell', 'sector', 'sector_id', 'sectorid']).toString().toLowerCase();
        if (!cell.includes(cellId)) {
          return false;
        }
      }
      
      // Duration filters
      const duration = parseInt(getField(record, ['duration', 'session_duration']), 10);
      if (minDuration && (!duration || duration < parseInt(minDuration, 10))) {
        return false;
      }
      
      if (maxDuration && duration > parseInt(maxDuration, 10)) {
        return false;
      }
      
      // IP Address filter
      if (ipAddress) {
        const ip = getField(record, ['ip', 'ip_address', 'ipaddress', 'mbl_ip', 'mbl_ip_addr', 'mbl ip addr']).toString().toLowerCase();
        if (!ip.includes(ipAddress)) {
          return false;
        }
      }
      
      // NAT IP Address filter
      if (natIpAddress) {
        const natIp = getField(record, ['nat_ip', 'nat_ip_address', 'nat ipaddress', 'nat ip addr', 'ext_ip']).toString().toLowerCase();
        if (!natIp.includes(natIpAddress)) {
          return false;
        }
      }
      
      // Technology filter
      if (technology) {
        const tech = getField(record, ['technology', 'tech', 'network_type', 'networktype']).toString().toLowerCase();
        if (!tech.includes(technology)) {
          return false;
        }
      }
      
      // Location filter
      if (location) {
        const loc = getField(record, ['location', 'cell_location', 'tower_location', 'site_location']).toString().toLowerCase();
        if (!loc.includes(location)) {
          return false;
        }
      }
      
      // Data volume filters
      const dataVolume = parseFloat(getField(record, ['data_volume', 'volume', 'data_usage', 'usage', 'bytes']));
      if (minDataVolume && (!dataVolume || dataVolume < parseFloat(minDataVolume))) {
        return false;
      }
      
      if (maxDataVolume && dataVolume > parseFloat(maxDataVolume)) {
        return false;
      }
      
      // Port allocation time filter
      if (portAllocTime && getField(record, ['port_alloc_date_time', 'port_alloc_date', 'port allocation date/time', 'port_allocation_date']) &&
          !getField(record, ['port_alloc_date_time', 'port_alloc_date', 'port allocation date/time', 'port_allocation_date']).toString().toLowerCase().includes(portAllocTime.toLowerCase())) {
        return false;
      }
      
      return true;
    });
  }

  // Apply dynamic filters for additional fields
  function applyDynamicFilters(records) {
    if (!currentFields) return records;
    
    const dynamicFields = currentFields.filter(field => field.isDynamic);
    if (dynamicFields.length === 0) return records;
    
    return records.filter(record => {
      for (const field of dynamicFields) {
        const filterInput = document.getElementById(`dynamicFilter_${field.keys[0]}`);
        if (!filterInput || !filterInput.value) continue;
        
        const filterValue = filterInput.value.toLowerCase();
        const fieldValue = record[field.keys[0]];
        
        if (!fieldValue) return false;
        
        if (field.type === 'number') {
          const numValue = parseFloat(fieldValue);
          const filterNum = parseFloat(filterValue);
          if (isNaN(numValue) || isNaN(filterNum) || numValue !== filterNum) {
            return false;
          }
        } else if (field.type === 'date') {
          // Simple date partial matching
          if (!fieldValue.toString().toLowerCase().includes(filterValue)) {
            return false;
          }
        } else {
          // Text field
          if (!fieldValue.toString().toLowerCase().includes(filterValue)) {
            return false;
          }
        }
      }
      return true;
    });
  }

  // Reset all filters and show full dataset
  function resetFilters() {
    // Reset call filters
    document.getElementById('startDate').value = '';
    document.getElementById('endDate').value = '';
    document.getElementById('minDuration').value = '';
    document.getElementById('maxDuration').value = '';
    document.getElementById('cellTower').value = '';
    document.getElementById('callDirection').value = '';
    document.getElementById('searchMsisdn').value = '';
    document.getElementById('searchLocation').value = '';
    document.getElementById('minTowers').value = '';
    document.getElementById('maxTowers').value = '';
    document.getElementById('groupByPhone').checked = false;
    
    // Reset message filters
    document.getElementById('msgStartDate').value = '';
    document.getElementById('msgEndDate').value = '';
    document.getElementById('msgType').value = '';
    document.getElementById('msgDirection').value = '';
    document.getElementById('msgContent').value = '';
    document.getElementById('msgSender').value = '';
    document.getElementById('msgRecipient').value = '';
    
    // Reset device filters
    document.getElementById('deviceId').value = '';
    document.getElementById('deviceType').value = '';
    document.getElementById('deviceMfg').value = '';
    
    // Reset data session filters
    document.getElementById('dsStartDate').value = '';
    document.getElementById('dsEndDate').value = '';
    document.getElementById('dsTowerId').value = '';
    document.getElementById('dsCellId').value = '';
    document.getElementById('dsMinDuration').value = '';
    document.getElementById('dsMaxDuration').value = '';
    document.getElementById('dsIpAddress').value = '';
    document.getElementById('dsNatIpAddress').value = '';
    document.getElementById('dsTechnology').value = '';
    document.getElementById('dsLocation').value = '';
    document.getElementById('dsMinDataVolume').value = '';
    document.getElementById('dsMaxDataVolume').value = '';
    document.getElementById('dsPortAllocTime').value = '';
    
    // Reset dynamic filters
    const dynamicFiltersContainer = document.getElementById('dynamicFilters');
    if (dynamicFiltersContainer) {
      const inputs = dynamicFiltersContainer.querySelectorAll('input, select');
      inputs.forEach(input => input.value = '');
    }
    
    // Reset general search
    document.getElementById('searchBox').value = '';
    document.getElementById('activeDataType').value = 'all';
    
    // Reset and render
    currentFilteredDataset = currentDataset.slice();
    renderData();
  }

  // Data Type Configuration Functions
  
  // Update the data type configuration UI based on selected data type
  function updateDataTypeConfig() {
    const dataTypeKey = document.getElementById('dataTypeSelector').value;
    const configArea = document.getElementById('dataTypeConfig');
    const fieldDefinitions = document.getElementById('fieldDefinitions');
    const dtName = document.getElementById('dtName');
    const dtIdentifier = document.getElementById('dtIdentifier');
    const editBtn = document.getElementById('editDataTypeBtn');
    const deleteBtn = document.getElementById('deleteDataTypeBtn');
    
    // Clear existing field definitions (except template)
    Array.from(fieldDefinitions.children).forEach(child => {
      if (!child.classList.contains('template')) {
        child.remove();
      }
    });
    
    if (dataTypeKey === 'new') {
      // Set up for new data type
      dtName.value = '';
      dtIdentifier.value = '';
      dtName.disabled = false;
      dtIdentifier.disabled = false;
      editBtn.disabled = true;
      deleteBtn.disabled = true;
    } else if (dataTypeKey && dataTypeDefinitions[dataTypeKey]) {
      // Load existing data type
      const dataType = dataTypeDefinitions[dataTypeKey];
      dtName.value = dataType.name;
      dtIdentifier.value = dataType.identifier;
      dtName.disabled = true; // Don't allow changing the name directly
      dtIdentifier.disabled = false;
      editBtn.disabled = false;
      deleteBtn.disabled = false;
      
      // Create field definition UI elements
      dataType.fields.forEach(field => {
        createFieldDefinitionUI(field);
      });
    } else {
      // No selection
      dtName.value = '';
      dtIdentifier.value = '';
      dtName.disabled = true;
      dtIdentifier.disabled = true;
      editBtn.disabled = true;
      deleteBtn.disabled = true;
    }
  }
  
  // Save current data type configuration
  function saveDataTypeConfig() {
    const dataTypeKey = document.getElementById('dataTypeSelector').value;
    const dtName = document.getElementById('dtName').value.trim();
    const dtIdentifier = document.getElementById('dtIdentifier').value.trim();
    
    if (!dtName || !dtIdentifier) {
      alert("Data type name and identifier pattern are required.");
      return;
    }
    
    // Collect field definitions
    const fieldElements = document.querySelectorAll('#fieldDefinitions .field-mapping:not(.template)');
    const fields = [];
    
    fieldElements.forEach(element => {
      const name = element.querySelector('.field-name').value.trim();
      const keysStr = element.querySelector('.field-keys').value.trim();
      const type = element.querySelector('.field-type').value;
      
      if (name && keysStr) {
        const keys = keysStr.split(',').map(k => k.trim()).filter(k => k);
        fields.push({ name, keys, type });
      }
    });
    
    if (fields.length === 0) {
      alert("At least one field definition is required.");
      return;
    }
    
    // Generate a key if creating a new data type
    let key = dataTypeKey;
    if (dataTypeKey === 'new') {
      key = dtName.toLowerCase().replace(/[^a-z0-9]/g, '_');
      // Make sure the key is unique
      if (dataTypeDefinitions[key]) {
        let counter = 1;
        while (dataTypeDefinitions[key + counter]) {
          counter++;
        }
        key = key + counter;
      }
    }
    
    // Save the data type definition
    dataTypeDefinitions[key] = {
      name: dtName,
      identifier: dtIdentifier,
      fields: fields
    };
    
    // Update UI
    updateDataTypeSelectors();
    alert(`Data type "${dtName}" has been saved.`);
    
    // Reset the form for a new data type
    document.getElementById('dataTypeSelector').value = '';
    updateDataTypeConfig();
  }
  
  // Delete a data type
  function deleteDataTypeConfig() {
    const dataTypeKey = document.getElementById('dataTypeSelector').value;
    if (!dataTypeKey || dataTypeKey === 'new' || !dataTypeDefinitions[dataTypeKey]) {
      alert("Please select a valid data type to delete.");
      return;
    }
    
    if (confirm(`Are you sure you want to delete the data type "${dataTypeDefinitions[dataTypeKey].name}"?`)) {
      delete dataTypeDefinitions[dataTypeKey];
      updateDataTypeSelectors();
      document.getElementById('dataTypeSelector').value = '';
      updateDataTypeConfig();
      alert("Data type deleted successfully.");
    }
  }
  
  // Export data type definitions
  function exportDataTypeDefinitions() {
    const definitionsJson = JSON.stringify(dataTypeDefinitions, null, 2);
    const blob = new Blob([definitionsJson], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "telecom_data_type_definitions.json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
  
  // Import data type definitions
  function importDataTypeDefinitions(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
      try {
        const importedDefinitions = JSON.parse(e.target.result);
        // Validate the format
        let isValid = true;
        for (const [key, definition] of Object.entries(importedDefinitions)) {
          if (!definition.name || !definition.identifier || !Array.isArray(definition.fields)) {
            isValid = false;
            break;
          }
        }
        
        if (isValid) {
          // Merge with existing definitions (overwrite duplicates)
          dataTypeDefinitions = { ...dataTypeDefinitions, ...importedDefinitions };
          updateDataTypeSelectors();
          alert("Data type definitions imported successfully.");
        } else {
          alert("The imported file contains invalid data type definitions.");
        }
      } catch (error) {
        console.error("Error importing data type definitions:", error);
        alert("Error importing data type definitions. Please check the file format.");
      }
    };
    reader.readAsText(file);
  }
  
  // Initialize the application
  function initializeApp() {
    // Initialize data types
    initializeDataTypes();
    
    // Set up event listeners
    document.getElementById('dataTypeSelector').addEventListener('change', updateDataTypeConfig);
    document.getElementById('editDataTypeBtn').addEventListener('click', function() {
      document.getElementById('dtName').disabled = false;
    });
    document.getElementById('saveDataTypeBtn').addEventListener('click', saveDataTypeConfig);
    document.getElementById('deleteDataTypeBtn').addEventListener('click', deleteDataTypeConfig);
    document.getElementById('exportDataTypesBtn').addEventListener('click', exportDataTypeDefinitions);
    document.getElementById('addFieldBtn').addEventListener('click', function() {
      createFieldDefinitionUI();
    });
    
    // Initialize the data type config UI
    updateDataTypeConfig();
    
    // Hide file type detection info initially
    document.getElementById('fileTypeDetection').style.display = 'none';
  }
  
  // Start the application when the DOM is loaded
  document.addEventListener('DOMContentLoaded', initializeApp);

  // Helper function to process Excel files
  function processExcelFile(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          
          // Get the first sheet
          const firstSheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[firstSheetName];
          
          // Convert to JSON with header row
          const jsonData = XLSX.utils.sheet_to_json(worksheet, { raw: false, defval: "" });
          
          // Extract headers (column names)
          // First, get the range of the sheet
          const range = XLSX.utils.decode_range(worksheet['!ref']);
          const headers = [];
          
          // Extract header row (assuming it's the first row)
          for (let C = range.s.c; C <= range.e.c; ++C) {
            const cellAddress = XLSX.utils.encode_cell({ r: range.s.r, c: C });
            const cell = worksheet[cellAddress];
            if (cell && cell.v) {
              // Clean and normalize headers
              let header = cell.v.toString().trim().toLowerCase();
              headers.push(header);
            }
          }
          
          console.log("Excel file processed with headers:", headers);
          console.log("Sample data:", jsonData.length > 0 ? jsonData[0] : "No data");
          
          resolve({ headers, rows: jsonData });
        } catch (error) {
          console.error("Error processing Excel file:", error);
          reject(error);
        }
      };
      reader.onerror = function(error) {
        console.error("Error reading file:", error);
        reject(error);
      };
      reader.readAsArrayBuffer(file);
    });
  }
</script>
</body>
</html>
